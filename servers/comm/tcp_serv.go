package comm

import (
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/des"
	"errors"
	"fmt"
	"io"
	"net"
	lnet "schat/lib/net"
	"schat/proto/ss"
	"sync"
	"time"
)

const (
	MAX_PKG_LEN = ss.MAX_SS_MSG_SIZE //200K

	TCP_SERV_ACC_TIMEOUT = 5 //tcp_serv accept timeout ms
	CLIENT_STAT_CLOSING  = 0
	CLIENT_STAT_NORMAL   = 1

	MAX_QUEUE_DATA = MAX_PKG_LEN //max queue data == max_pkg_len
	//RECV_QUEUE_LEN=128
	SND_QUEUE_LEN = 128

	SERV_RECV_QUEUE  = 4096
	SERV_SND_QUEUE   = 4096
	MAX_PKG_PER_RECV = 200 //max pkg per recv

	//QUEUE_INFO
	QUEUE_INFO_NORMAL    = 0
	QUEUE_INFO_CLOSE     = 1
	QUEUE_INFO_BROADCAST = 2

	//ClientPkg.PkgType
	CLIENT_PKG_T_NORMAL      = 1 // special pkg using key
	CLIENT_PKG_T_BROADCAST   = 2 //broadcast pkg
	CLIENT_PKG_T_CONN_CLOSED = 3 //client connection closed
	CLIENT_PKG_T_CLOSE_CONN  = 4 //close client

	//R&W TIMEOUT
	CLIENT_RW_TIMEOUT = 2 //ms
	//RW CACHE
	CLIENT_RW_CACHE_SHRINK_FACTOR = 4           //if cache_size / base_size > factor will shrink memory
	CLIENT_RW_CACHE_BASE          = (10 * 1024) //base 10K
)

/*Caller Proc <-> tcp_serv */
type ClientPkg struct {
	PkgType int8
	//Flag uint8
	ClientKey int64 //the key identify a client
	Data      []byte
}

type queue_data struct {
	flag uint8 //tag net_pkg.PKG_OP_XX
	info uint8
	idx  int //index of client
	key  int64
	data []byte
}

type tcp_client struct {
	stat         int8 //refer CLIENT_STAT_XX
	key          int64
	server_close bool         //if connection closed , true:server close connection; false:client close connection
	conn         *net.TCPConn //connection
	need_valid   bool         //if need valid
	valid        bool         //if validate
	enc_type     int8         // encrypt type 0:no 1:des-ecb 2:aes-cbc-128 3:rsa
	enc_key      []byte       // encrypt key if method==rsa this is generated by negotiate
	enc_block    cipher.Block // encrypt block
	index        int          //index in client-array
	read_cache   []byte       //each read into buff = cache_base
	recv_cache   []byte
	snd_cache    []byte
	//recv_queue chan *queue_data //client -> server
	snd_queue chan *queue_data //server -> client
}

type TcpServ struct {
	sync.Mutex
	addr        string
	max_conn    int
	curr_conn   int
	valid_conn  int8
	enc_type    int8
	rsa_pub_key []byte
	rsa_pri_key []byte
	close_ch    chan int      //closing connection
	client_list []*tcp_client //client
	exit_ch     chan bool     //exit channel
	loop_index  int
	recv_queue  chan *queue_data //client -> server
	snd_queue   chan *queue_data //server -> client
	key_map     map[int64]int    //client_key <-> client_idx 多协程直接读写map unsafe , 会crash掉 如果不能保证则需要使用sync.Map
	config      *CommConfig
}

//temp save *queue_data
var queue_pool sync.Pool

//var queue_pool *TinyPool;

func init() {
	//queue_pool = NewTinyPool(2000 , func() interface{} {return new(queue_data)});
	queue_pool.New = func() interface{} {
		return new(queue_data)
	}
}

//new tcp_serv and start listener serve
//rsa_pub_key & rsa_pri_key is needed when enc_type==NET_ENCRYPT_RSA
func StartTcpServ(pconfig *CommConfig, addr string, max_conn int, valid_conn int8, enc_type int8, rsa_pub_key []byte,
	rsa_pri_key []byte) *TcpServ {
	var _func_ = "<StartTcpServ>"
	log := pconfig.Log

	//new
	pserv := new(TcpServ)

	//init
	pserv.addr = addr
	//pserv.max_conn = max_conn
	pserv.curr_conn = 0
	pserv.close_ch = make(chan int, max_conn)
	pserv.client_list = make([]*tcp_client, max_conn) //init
	pserv.exit_ch = make(chan bool, 1)                //non-block
	pserv.recv_queue = make(chan *queue_data, SERV_RECV_QUEUE)
	pserv.snd_queue = make(chan *queue_data, SERV_SND_QUEUE)
	pserv.key_map = make(map[int64]int)
	pserv.valid_conn = valid_conn
	pserv.enc_type = enc_type
	if pserv.enc_type == lnet.NET_ENCRYPT_RSA {
		if rsa_pub_key == nil || len(rsa_pub_key) == 0 || rsa_pri_key == nil || len(rsa_pri_key) == 0 {
			log.Err("%s failed! net encrypt rsa but rsa keys not set!", _func_)
			return nil
		}
		pserv.rsa_pub_key = make([]byte, len(rsa_pub_key))
		copy(pserv.rsa_pub_key, rsa_pub_key)

		pserv.rsa_pri_key = make([]byte, len(rsa_pri_key))
		copy(pserv.rsa_pri_key, rsa_pri_key)
	}
	pserv.config = pconfig
	//start
	go tcp_server(pconfig, pserv)
	log.Info("%s at %s finish!", _func_, addr)
	return pserv
}

/*
close tcp serv
*/
func (pserv *TcpServ) Close(pconfig *CommConfig) {
	log := pconfig.Log
	log.Info("tcp_serv closing... addr:%s", pserv.addr)
	pserv.exit_ch <- true
}

/*read from clients
@return: nil:read fail or empty; []*ClientPkg read success
*/
func (pserv *TcpServ) Recv(pconfig *CommConfig, pkgs []*ClientPkg) int {
	var pdata *queue_data
	var _func_ = "TcpServ.Recv"
	log := pconfig.Log
	result_len := len(pserv.recv_queue)

	//empty
	if result_len <= 0 {
		return 0
	}

	//init results
	if result_len > MAX_PKG_PER_RECV { //max pkgs per handle
		result_len = MAX_PKG_PER_RECV
	}
	if result_len > len(pkgs) {
		result_len = len(pkgs)
	}

	//results := make([]*ClientPkg, result_len)
	i := 0
	//fulfill result
	for {
		if i >= result_len {
			break
		}

		select {
		case pdata = <-pserv.recv_queue:
			if pdata.info == QUEUE_INFO_NORMAL {
				pkgs[i].PkgType = CLIENT_PKG_T_NORMAL
			} else if pdata.info == QUEUE_INFO_CLOSE {
				log.Info("%s [%d] read close connection! key:%v idx:%v", _func_, i, pdata.key, pdata.idx)
				pkgs[i].PkgType = CLIENT_PKG_T_CONN_CLOSED
			}
			pkgs[i].ClientKey = pdata.key
			pkgs[i].Data = pdata.data
			i++
			//restore pdata
			queue_pool.Put(pdata)
		default: //no data
			return i
		}

	}

	//log.Debug("%s recv pkg:%d" , _func_ , result_len);
	return i
}

/*Send pkg to client
@return: -1: failed 0:success
*/
func (pserv *TcpServ) Send(pconfig *CommConfig, ppkg *ClientPkg) int {
	var _func_ = "<TcpServ.Send>"
	log := pconfig.Log
	//check cap
	if len(pserv.snd_queue) >= cap(pserv.snd_queue) {
		log.Err("%s failed! send_queue full!", _func_)
		return -1
	}

	if len(ppkg.Data) >= MAX_PKG_LEN {
		log.Err("%s failed! pkg data overflow! len:%d max:%d curr_key:%d", _func_, len(ppkg.Data), MAX_PKG_LEN, ppkg.ClientKey)
		return -1
	}

	//check key
	/*
		idx  , ok := pserv.key_map[ppkg.ClientKey];
		if !ok {
			log.Err("%s client not exist! key:%d" , _func_ , ppkg.ClientKey);
			return -1;
		}*/

	//send
	pv := queue_pool.Get()
	pdata, ok := pv.(*queue_data)
	var pkg_data []byte
	if !ok {
		log.Debug("%s get fail! new queue_data!", _func_)
		pdata = new(queue_data)
	}
	pdata.info = QUEUE_INFO_NORMAL
	pdata.flag = lnet.PKG_OP_NORMAL
	//pdata.idx = idx; 这里故意不设置idx防止竞争读取kep_map 指导tcp_serv主协程去设置
	pkg_data = ppkg.Data

	if pdata.data != nil && cap(pdata.data) >= len(pkg_data) {
		log.Debug("%s reuse pdata.data!", _func_)
		pdata.data = pdata.data[:len(pkg_data)]
	} else {
		log.Debug("%s new pdata.data!", _func_)
		pdata.data = make([]byte, len(pkg_data))
	}
	copy(pdata.data, pkg_data)
	pdata.key = ppkg.ClientKey
	//check pkg type
	switch ppkg.PkgType {
	case CLIENT_PKG_T_CLOSE_CONN:
		log.Info("%s dectect positive close connection! key:%d", _func_, pdata.key)
		pdata.info = QUEUE_INFO_CLOSE //will close connection
	case CLIENT_PKG_T_BROADCAST:
		log.Info("%s dectect broadcast!", _func_)
		pdata.info = QUEUE_INFO_BROADCAST
	default:
		//normal pkg
	}
	pserv.snd_queue <- pdata
	return 0
}

func (pserv *TcpServ) GetConnNum() int {
	return pserv.curr_conn
}

func (pserv *TcpServ) SetMaxConn(max_conn int) {
	if max_conn <= 0 {
		return
	}
	pserv.max_conn = max_conn
}

/*--------------------------Static Func----------------------------*/
/*--------------------------------tcp_server-----------------------------*/
//generate key
func generate_client_key(idx int) int64 {
	var key int64 = 0
	curr_ts := time.Now().UnixNano() / 1000 / 1000 //ms

	key |= int64(((idx + 1&0xFFFF) << 44))
	key |= (curr_ts & 0xFFFFFFFFFFF)
	return key
}

//go routine of listener
func tcp_server(pconfig *CommConfig, pserv *TcpServ) {
	var _func_ = "<tcp_server>"
	var log = pconfig.Log
	log.Info("%s starting...", _func_)
	defer func() {
		if err := recover(); err != nil {
			pconfig.Log.Err("tcp_server.serve panic! err:%v", err)
			fmt.Printf("tcp_server.serve panic! err:%v\n", err)
		}
	}()
	//addr
	serv_addr, err := net.ResolveTCPAddr("tcp4", pserv.addr)
	if err != nil {
		log.Err("resolve addr:%s failed! err:%v", pserv.addr, err)
		return
	}

	//listen
	listener, err := net.ListenTCP("tcp4", serv_addr)
	if err != nil {
		log.Err("%s listen at %s failed! err:%v", _func_, pserv.addr, err)
		return
	}

	log.Info("%s listen at %s done!", _func_, pserv.addr)
	//accept
	for {
		//check exit
		if len(pserv.exit_ch) > 0 {
			log.Info("%s detect exit flg!", _func_)
			return
		}
		/*
			select {
			case <-pserv.exit_ch:
				log.Info("%s detect exit flg!", _func_)
				return
			default:
				//nothing
			}*/

		//set deadline 5ms
		listener.SetDeadline(time.Now().Add(TCP_SERV_ACC_TIMEOUT * time.Millisecond))

		//acc
		conn, err := listener.AcceptTCP()
		if err != nil {
			if net_err, ok := err.(net.Error); ok {
				if net_err.Temporary() || net_err.Timeout() { //timeout no-err
					//log.Debug("%s time out." , _func_);
				} else {
					log.Err("%s accept net-err fail! err:%v", _func_, err)
					conn.Close()
				}
			} else {
				log.Err("%s accept fail! err:%v", _func_, err)
				conn.Close()
			}
		} else {
			//wrap connection
			log.Info("%s accept a new connection! peer:%s", _func_, conn.RemoteAddr().String())

			//add client
			pserv.add_client(pconfig, conn)
		}

		//close clients
		pserv.close_clients(pconfig)

		//dispatch send pkg
		pserv.dispatch_send_pkg(pconfig)
	}

}

//detect and close closing clients
func (pserv *TcpServ) close_clients(pconfig *CommConfig) {
	var _func_ = "<tcp_serv.close_clients>"
	log := pconfig.Log

	//check closing
	if len(pserv.close_ch) <= 0 {
		return
	}

	//close
	for {
		select {
		case idx := <-pserv.close_ch:
			pclient := pserv.client_list[idx]
			//notify upper server if client close
			if !pclient.server_close {
				pdata := new(queue_data)
				pdata.key = pclient.key
				pdata.idx = pclient.index
				pdata.info = QUEUE_INFO_CLOSE
				pserv.recv_queue <- pdata
			}

			//close
			close_client(pconfig, pclient)
			delete(pserv.key_map, pserv.client_list[idx].key)
			pserv.client_list[idx] = nil
			pserv.curr_conn--
			log.Info("%s will close connection idx:%d curr_count:%d", _func_, idx, pserv.curr_conn)
		default:
			return
		}
	}

}

func close_connection(pconfig *CommConfig, conn *net.TCPConn) {
	if conn != nil {
		conn.Close()
	}
}

//add a client to tcp_serv
func (pserv *TcpServ) add_client(pconfig *CommConfig, conn *net.TCPConn) {
	var _func_ = "<tcp_serv.add_client>"
	log := pconfig.Log
	defer func() {
		if err := recover(); err != nil {
			pconfig.Log.Err("tcp_serv.add_client panic! err:%v", err)
			fmt.Printf("tcp_serv.add_client failed! err:%v", err)
		}
	}()

	//check conn count
	if pserv.curr_conn >= len(pserv.client_list) {
		log.Err("%s fail! connection count:%d reached uplimit!", _func_, pserv.curr_conn)
		close_connection(pconfig, conn)
		return
	}

	//search an empty index
	var i = 0
	//pserv.Lock()
	for i = 0; i < len(pserv.client_list); i++ {
		if pserv.client_list[i] == nil {
			break
		}
	}
	//pserv.Unlock()
	if i >= len(pserv.client_list) {
		log.Err("%s fail! no empy pos found! curr:%d max:%d", _func_, pserv.curr_conn, len(pserv.client_list))
		close_connection(pconfig, conn)
		return
	}

	//new client
	pclient := pserv.new_client()
	if pclient == nil {
		log.Err("%s fail! new_client failed!", _func_)
		close_connection(pconfig, conn)
		return
	}
	pclient.index = i
	pclient.conn = conn
	pclient.stat = CLIENT_STAT_NORMAL
	pclient.key = generate_client_key(i)

	//add client
	//pserv.Lock()
	pserv.client_list[i] = pclient
	pserv.curr_conn++
	pserv.key_map[pclient.key] = pclient.index
	//pserv.Unlock()

	log.Info("%s at %s success! index:%d curr_count:%d", _func_, pserv.addr, i, pserv.curr_conn)
	go pclient.run(pconfig, pserv)
	return
}

/*
dispatch tcp_serv.send_queue to each client
*/
func (pserv *TcpServ) dispatch_send_pkg(pconfig *CommConfig) {
	var _func_ = "<tcpserver.dispatch_send_pkg>"
	log := pconfig.Log

	//check channel
	ch_len := len(pserv.snd_queue)
	if ch_len <= 0 {
		return
	}

	var pdata *queue_data
	var idx int
	var pclient *tcp_client
	var ok bool
	//dispatch
	for i := 0; i < ch_len; i++ {
		//queue_data
		pdata = <-pserv.snd_queue

		//check index
		idx, ok = pserv.key_map[pdata.key]
		if !ok {
			log.Err("%s client not exist any more! c_key:%d", _func_, pdata.key)
			continue
		}
		pdata.idx = idx

		if idx >= len(pserv.client_list) || idx < 0 || pserv.curr_conn <= 0 {
			log.Err("%s illegal pkg! idx error. idx:%d", _func_, idx)
			continue
		}
		pclient = pserv.client_list[pdata.idx]

		//check connection
		if pclient.stat == CLIENT_STAT_CLOSING {
			log.Info("%s detect closing client idx:%d drop pkg!", _func_, idx)
			continue
		}

		//valid key
		if pclient.key != pdata.key {
			log.Info("%s key not matched %v <-> %v idx:%d", _func_, pclient.key, pdata.key, idx)
			continue
		}

		//append to client queue
		//log.Debug("%s append to client idx:%d data:%v success!" , _func_ , idx , pdata.data);
		pclient.append_send_data(pconfig, pdata)
		/*
				if len(pclient.snd_queue) >= cap(pclient.snd_queue) {
				    log.Err("%s fail! client snd_queue full! drop pkg! idx:%d" , _func_ , pclient.index);
				    continue;
			    }
			    //add
			    pclient.snd_queue <- pdata;*/
	}

}

/*--------------------------------tcp_client-----------------------------*/
//create a new tcp_client
func (pserv *TcpServ) new_client() *tcp_client {
	var _func_ = "<tcp_serv.new_client>"
	log := pserv.config.Log

	//new
	pclient := new(tcp_client)

	pclient.server_close = false
	pclient.read_cache = make([]byte, CLIENT_RW_CACHE_BASE)
	pclient.recv_cache = make([]byte, CLIENT_RW_CACHE_BASE) //pre alloc cache
	pclient.recv_cache = pclient.recv_cache[:0]
	pclient.snd_cache = make([]byte, CLIENT_RW_CACHE_BASE)
	pclient.snd_cache = pclient.snd_cache[:0]
	//pclient.recv_queue = make(chan *queue_data , RECV_QUEUE_LEN);
	pclient.snd_queue = make(chan *queue_data, SND_QUEUE_LEN)
	pclient.valid = false
	pclient.enc_type = pserv.enc_type
	if pserv.valid_conn != 0 {
		pclient.need_valid = true
	}

	//generate key
	switch pclient.enc_type {
	case lnet.NET_ENCRYPT_DES_ECB:
		rand_str, err := GenRandStr(lnet.ENCRY_DES_KEY_LEN)
		if err != nil {
			log.Err("%s generate des key failed! err:%v", _func_, err)
			return nil
		}
		pclient.enc_key = make([]byte, len(rand_str))
		copy(pclient.enc_key, rand_str)
		pclient.enc_block, err = des.NewCipher(pclient.enc_key)
		if err != nil {
			log.Err("%s new des cipher for key:%s failed! err:%v", _func_, rand_str, err)
			return nil
		}
	case lnet.NET_ENCRYPT_AES_CBC_128:
		rand_str, err := GenRandStr(lnet.ENCRY_AES_KEY_LEN)
		if err != nil {
			log.Err("%s generate aes-128 key failed! err:%v", _func_, err)
			return nil
		}
		pclient.enc_key = make([]byte, len(rand_str))
		copy(pclient.enc_key, rand_str)
		pclient.enc_block, err = aes.NewCipher(pclient.enc_key)
		if err != nil {
			log.Err("%s new aes cipher for key:%s failed! err:%v", _func_, pclient.enc_key, err)
			return nil
		}
	case lnet.NET_ENCRYPT_RSA:
		//enc_key and block is generated by negotiate
	default:
		//nothint to do
	}

	return pclient
}

//close a tcp_client
func close_client(pconfig *CommConfig, pclient *tcp_client) {
	var _func_ = "<close_client>"
	log := pconfig.Log

	//close connection
	err := pclient.conn.Close()
	if err != nil {
		log.Err("%s close conn err:%v idx:%d", _func_, err, pclient.index)
	}

	//clear data
	pclient.conn = nil
	pclient.snd_cache = nil
	pclient.recv_cache = nil
	//pclient.snd_queue = nil;
	//pclient.recv_queue = nil;
	return
}

//client go-routine
func (pclient *tcp_client) run(pconfig *CommConfig, pserv *TcpServ) {
	defer func() {
		if err := recover(); err != nil {
			pconfig.Log.Err("%s failed! err:%v", "client.run", err)
			fmt.Printf("%s failed! err:%v", "client.run", err)
		}
	}()

	for {
		//exit-goroutine
		if pclient.stat == CLIENT_STAT_CLOSING {
			break
		}

		//read from client
		pclient.read(pconfig, pserv)

		//send to client
		pclient.send(pconfig, pserv)

		//sleep
		time.Sleep(1 * time.Millisecond)
	}

}

//append send_data
func (pclient *tcp_client) append_send_data(pconfig *CommConfig, pdata *queue_data) {
	var _func_ = "<tcp_client.append_send_data>"
	log := pconfig.Log

	if len(pclient.snd_queue) >= cap(pclient.snd_queue) {
		log.Err("%s fail! client snd_queue full! drop pkg! idx:%d", _func_, pclient.index)
		return
	}

	//add
	pclient.snd_queue <- pdata
}

//handle special pkg
func (pclient *tcp_client) handle_spec_pkg(pconfig *CommConfig, pserv *TcpServ, pkg_option uint8, pkg_data []byte) {
	var _func_ = "<tcp_client.handle_spec_pkg>"
	log := pconfig.Log
	pdata := new(queue_data)
	pdata.key = pclient.key
	pdata.idx = pclient.index
	pdata.flag = pkg_option
	pdata.info = QUEUE_INFO_NORMAL

	//switch
	switch pdata.flag {
	case lnet.PKG_OP_ECHO:
		log.Info("%s pkg option:%d [echo]", _func_, pdata.flag)
		pdata.data = make([]byte, len(pkg_data))
		copy(pdata.data, pkg_data)
		//resend
		pclient.append_send_data(pconfig, pdata)
	case lnet.PKG_OP_VALID:
		log.Info("%s pkg option:%d [valid] key:%s", _func_, pdata.flag, string(pclient.enc_key))
		if pclient.need_valid && bytes.Compare(pkg_data, []byte(lnet.CONN_VALID_KEY)) != 0 {
			log.Err("%s get stat fail! illegal key!", _func_)
			break
		}
		pclient.valid = true
		//msg := "{\"stat\":0, \"conn\":" + strconv.Itoa(pserv.curr_conn) + "}"\
		switch pclient.enc_type {
		case lnet.NET_ENCRYPT_NONE, lnet.NET_ENCRYPT_DES_ECB, lnet.NET_ENCRYPT_AES_CBC_128:
			msg, _ := GenRandStr(128)
			pdata.data = make([]byte, len(msg))
			copy(pdata.data, msg)
			pdata.data[0] = byte(pclient.enc_type)
			copy(pdata.data[1:], pclient.enc_key)
		case lnet.NET_ENCRYPT_RSA:
			pdata.data = make([]byte, len(pserv.rsa_pub_key)+1)
			pdata.data[0] = byte(pclient.enc_type)
			copy(pdata.data[1:], pserv.rsa_pub_key)
		default:
			log.Err("%s illegal enc_type:%d", _func_, pclient.enc_type)
		}
		//resend
		pclient.append_send_data(pconfig, pdata)
	case lnet.PKG_OP_RSA_NEGO:
		log.Info("%s pkg option:%d [rsa_nego]", _func_, pdata.flag)
		//resp
		pdata.data = make([]byte, 12)
		//decode by rsa_priv
		decoded, err := lnet.RsaDecrypt(pkg_data, pserv.rsa_pri_key)
		for {
			if err != nil {
				log.Err("%s RsaDecrypt Failed! err:%v c_key:%d", _func_, err, pclient.key)
				copy(pdata.data, "fail")
				break
			}
			if len(decoded) != lnet.ENCRY_DES_KEY_LEN {
				log.Err("%s RsaDecrypt inner key lenth:%d illegal!", _func_, len(decoded))
				copy(pdata.data, "key_len")
				break
			}
			enc_block, err := des.NewCipher(decoded)
			if err != nil {
				log.Err("%s new des cipher for key:%v failed! err:%v", _func_, decoded, err)
				copy(pdata.data, "sys_err")
				break
			}
			//accept des key
			log.Info("%s accept des key:%v c_key:%d", _func_, decoded, pclient.key)
			copy(pdata.data, "ok")
			pclient.enc_key = make([]byte, lnet.ENCRY_DES_KEY_LEN)
			copy(pclient.enc_key, decoded)
			pclient.enc_block = enc_block
			break
		}
		//resend
		pclient.append_send_data(pconfig, pdata)
	default:
		log.Info("%s unhandle pkg option:%d", _func_, pdata.flag)
	}

	return
}

func (pclient *tcp_client) read(pconfig *CommConfig, pserv *TcpServ) {
	var _func_ = "<tcp_client.read>"
	var read_len = 0
	var parsed int = 0
	var err error

	log := pconfig.Log
	conn := pclient.conn
	read_data := pclient.read_cache

	defer func() {
		if err := recover(); err != nil {
			pconfig.Log.Err("tcp_client.read panic! err:%v", err)
			fmt.Printf("tcp_client.read panic! err:%v\n", err)
		}
	}()

	if pclient.stat == CLIENT_STAT_CLOSING {
		log.Info("%s in closing! index:%d", _func_, pclient.index)
		return
	}

	//consist read
	for {
		read_data = read_data[:cap(read_data)]
		//set dead line
		conn.SetReadDeadline(time.Now().Add(CLIENT_RW_TIMEOUT * time.Millisecond)) //set timeout

		//read
		read_len, err = conn.Read(read_data)
		//check err
		if err != nil { //parse err
			close_conn := true
			//net err
			if net_err, ok := err.(net.Error); ok {
				if net_err.Temporary() || net_err.Timeout() { //no data prepared
					//log.Debug("%s no data" , _func_);
					close_conn = false
				} else { //other
					log.Err("%s connection net.err other! will close conn! detail:%v index:%d", _func_, err, pclient.index)
				}
			} else if err == io.EOF { //read a closed connection
				log.Info("%s connection closed! index:%d", _func_, pclient.index)
			} else { //other
				log.Err("%s read meets an error! will close! err:%v index:%d", _func_, err, pclient.index)
			}

			//need close
			if close_conn {
				pclient.stat = CLIENT_STAT_CLOSING
				pserv.close_ch <- pclient.index
			}
			return
		}

		//empty useless
		if read_len == 0 {
			log.Info("%s peer closed will close connection index:%d!", _func_, pclient.index)
			pclient.stat = CLIENT_STAT_CLOSING
			pserv.close_ch <- pclient.index
			return
		}

		//append readed
		//log.Debug("%s read %d bytes" , _func_ , read_len);
		pclient.recv_cache = append(pclient.recv_cache, read_data[:read_len]...) //may expand cap(recv_cache)

		//flush cache
		parsed = pclient.flush_recv_cache(pconfig, pserv)
		if parsed < 0 {
			log.Err("%s pkg data illegal! will close connection! idx:%d", _func_, pclient.index)
			pclient.stat = CLIENT_STAT_CLOSING
			pserv.close_ch <- pclient.index
			return
		}
		//log.Debug("%s flush %d pkgs! idx:%d", _func_, parsed, pclient.index)

	}

}

//encrypt data
//only for normal pkg
func (pclient *tcp_client) encrypt(src []byte) ([]byte, error) {
	var encoded []byte
	var err error
	//encrypt
	switch pclient.enc_type {
	case lnet.NET_ENCRYPT_NONE:
		return src, nil
	case lnet.NET_ENCRYPT_DES_ECB:
		encoded, err = lnet.DesEncrypt(pclient.enc_block, src, pclient.enc_key)
		if err != nil {
			return nil, errors.New("des encrypt failed! err:" + err.Error())
		}
	case lnet.NET_ENCRYPT_AES_CBC_128:
		encoded, err = lnet.AesEncrypt(pclient.enc_block, src, pclient.enc_key)
		if err != nil {
			return nil, errors.New("aes encrypt failed! err:" + err.Error())
		}
	case lnet.NET_ENCRYPT_RSA:
		//must negotiate des key first by option:PKG_OP_RSA_NEGO
		if pclient.enc_block == nil || len(pclient.enc_key) != lnet.ENCRY_DES_KEY_LEN {
			return nil, errors.New("Rsa method must negotiate des key first!")
		}
		encoded, err = lnet.DesEncrypt(pclient.enc_block, src, pclient.enc_key)
		if err != nil {
			return nil, errors.New("rsa_des encrypt failed! err:" + err.Error())
		}
	default:
		return nil, errors.New(fmt.Sprintf("illegal enc_type:%d", pclient.enc_type))
	}

	return encoded, nil
}

//decrypt data
//only for normal pkg
func (pclient *tcp_client) decrypt(src []byte) ([]byte, error) {
	var decoded []byte
	var err error
	//decrypt
	switch pclient.enc_type {
	case lnet.NET_ENCRYPT_NONE:
		return src, nil
	case lnet.NET_ENCRYPT_DES_ECB:
		decoded, err = lnet.DesDecrypt(pclient.enc_block, src, pclient.enc_key)
		if err != nil {
			return nil, errors.New("des decrypt failed! err:" + err.Error())
		}
	case lnet.NET_ENCRYPT_AES_CBC_128:
		decoded, err = lnet.AesDecrypt(pclient.enc_block, src, pclient.enc_key)
		if err != nil {
			return nil, errors.New("aes decrypt failed! err:" + err.Error())
		}
	case lnet.NET_ENCRYPT_RSA:
		//must negotiate des key first by option:PKG_OP_RSA_NEGO
		if pclient.enc_block == nil || len(pclient.enc_key) != lnet.ENCRY_DES_KEY_LEN {
			return nil, errors.New("Rsa method must negotiate des key first!")
		}
		decoded, err = lnet.DesDecrypt(pclient.enc_block, src, pclient.enc_key)
		if err != nil {
			return nil, errors.New("rsa_des decrypt failed! err:" + err.Error())
		}
	default:
		return nil, errors.New(fmt.Sprintf("illegal enc_type:%d", pclient.enc_type))
	}

	return decoded, nil
}

/*parse read bytes to queue-data
@return: -1:error 0:not ready else:handled count of pkg
*/
func (pclient *tcp_client) flush_recv_cache(pconfig *CommConfig, pserv *TcpServ) int {
	var _func_ = "<tcp_client.flush_recv_cache>"
	log := pconfig.Log
	var tag uint8
	var pkg_data []byte
	var pkg_len int
	var raw_data []byte
	var parsed int
	var err error
	raw_data = pclient.recv_cache
	for {
		//unpack raw data
		tag, pkg_data, pkg_len = lnet.UnPackPkg(raw_data)

		//error
		if tag == 0xFF {
			log.Err("%s error! pkg format illegal!", _func_)
			return -1
		}

		//not- ready
		if tag == 0 {
			log.Debug("%s pkg not ready!", _func_)
			//not moving memory
			if parsed == 0 {
				break
			}

			//reset cache
			copy(pclient.recv_cache[:cap(pclient.recv_cache)], raw_data[:])
			log.Debug("%s saving  cached %d bytes", _func_, len(raw_data))
			break
		}

		//parse success
		parsed++

		//check basic info
		for {
			//lenth too long
			if pkg_len > MAX_PKG_LEN {
				log.Err("%s drop pkg for lenth overflow! pkg_len:%d max_len:%d idx:%d", _func_, pkg_len, MAX_PKG_LEN, pclient.index)
				break
			}

			//valid(data trans must after validation if valid flag open)
			pkg_option := lnet.PkgOption(tag)
			if pkg_option == lnet.PKG_OP_NORMAL && pclient.need_valid && !pclient.valid {
				log.Err("%s connection not valid yet! key:%d will close it", _func_, pclient.key)
				return -1
			}

			//spec
			if pkg_option != lnet.PKG_OP_NORMAL {
				pclient.handle_spec_pkg(pconfig, pserv, pkg_option, pkg_data)
				break
			}

			//normal pkg
			pv := queue_pool.Get()
			pdata, ok := pv.(*queue_data)
			if !ok {
				log.Debug("%s renew", _func_)
				pdata = new(queue_data)
			}

			//decrypt
			pkg_data, err = pclient.decrypt(pkg_data)
			if err != nil {
				log.Err("%s decrypt failed! err:%v", _func_, err)
				return -1
			} else {
				log.Debug("%s decrypt done!", _func_)
			}

			//may reuse pdata.data
			if pdata.data != nil && cap(pdata.data) >= len(pkg_data) {
				log.Debug("%s just reuse pdata.data", _func_)
				pdata.data = pdata.data[:len(pkg_data)]
			} else {
				log.Debug("%s new pdata.data", _func_)
				pdata.data = make([]byte, len(pkg_data))
			}
			pdata.key = pclient.key
			copy(pdata.data, pkg_data)
			pdata.idx = pclient.index
			pdata.flag = pkg_option
			pdata.info = QUEUE_INFO_NORMAL
			pserv.recv_queue <- pdata
			break
		}

		//forward
		raw_data = raw_data[pkg_len:]
		if len(raw_data) <= 0 {
			pclient.recv_cache = pclient.recv_cache[:0] //clear cache
			//log.Debug("%s no more data! may resize recv_cache" , _func_);
			//recv may expand cache cap
			if cap(pclient.recv_cache) > CLIENT_RW_CACHE_BASE*CLIENT_RW_CACHE_SHRINK_FACTOR {
				new_cap := cap(pclient.recv_cache) / 2
				if new_cap < CLIENT_RW_CACHE_BASE {
					new_cap = CLIENT_RW_CACHE_BASE
				}
				log.Info("%s shrink recv_cache from %d to %d idx:%d", _func_, cap(pclient.recv_cache), new_cap)
				pclient.recv_cache = make([]byte, new_cap) //new buffer
				pclient.recv_cache = pclient.recv_cache[:0]
			}

			break
		}

	}

	return parsed
	//pclient.recv_cache = pclient.recv_cache[:0]; //reset
}

//send pkg to client
func (pclient *tcp_client) send(pconfig *CommConfig, pserv *TcpServ) {
	var _func_ = "<tcp_client.send>"
	log := pconfig.Log
	//check conn
	if pclient.stat == CLIENT_STAT_CLOSING {
		return
	}

	//flush cache 1st
	if len(pclient.snd_cache) > 0 {
		ret := pclient.flush_send_cache(pconfig, pserv)
		if ret < 0 {
			log.Err("%s 1st flush failed! will close conn. idx:%d", _func_, pclient.index)
			return
		}

		if ret == 1 {
			log.Debug("%s 1st send part of data! idx:%d", _func_, pclient.index)
			return
		}

		//ret == 0 empty cache
	}

	//check send_queue
	snd_len := len(pclient.snd_queue)
	if snd_len <= 0 {
		return
	}

	//log.Debug("%s snd_queue_len:%d idx:%d" , _func_ , snd_len , pclient.index);
	//handle each pkg
	var pdata *queue_data
	var data_len int
	var pkg_len int
	var ret int
	var send_pkg int
	var snd_data []byte
	var err error
	for i := 0; i < snd_len; i++ {
		//fetch a pkg
		pdata = <-pclient.snd_queue
		snd_data = pdata.data

		//check data option
		if pdata.info == QUEUE_INFO_CLOSE {
			log.Info("%s detect info close. will close this connection! c_key:%d idx:%d", _func_,
				pclient.key, pclient.index)
			pclient.stat = CLIENT_STAT_CLOSING
			pclient.server_close = true
			pserv.close_ch <- pclient.index
			return
		}

		//encrypt data
		//only for normal pkg
		if pdata.flag == lnet.PKG_OP_NORMAL {
			snd_data, err = pclient.encrypt(snd_data)
			if err != nil {
				log.Err("%s encrypt failed! err:%v c_key:%d", _func_, err, pclient.key)
				continue
			} else {
				log.Debug("%s encrypt done!", _func_)
			}
		}
		data_len = len(snd_data)

		//pack pkg
		if cap(pclient.snd_cache) < data_len {
			new_cap := lnet.GetPkgLen(data_len) + 4
			log.Debug("%s resize snd cache cap: from %d --> %d", _func_, cap(pclient.snd_cache), new_cap)
			pclient.snd_cache = make([]byte, new_cap)
		}
		pkg_len = lnet.PackPkg(pclient.snd_cache[:cap(pclient.snd_cache)], snd_data, pdata.flag)
		if pkg_len < 0 {
			log.Err("%s pack error! will drop pkg! idx:%d", _func_, pclient.index)
			break
		}

		pclient.snd_cache = pclient.snd_cache[:pkg_len]
		//log.Debug("%s pkg_len:%d data:%v flag:%d" , _func_ , pkg_len , pclient.snd_cache , pdata.flag);

		//flush cache
		ret = pclient.flush_send_cache(pconfig, pserv)
		if ret < 0 {
			log.Err("%s 2nd flush failed! will close conn. idx:%d", _func_, pclient.index)
			return
		}

		if ret == 1 {
			log.Debug("%s 2nd send part of data! idx:%d", _func_, pclient.index)
			//restore pdata
			queue_pool.Put(pdata)
			break
		}

		//continue send
		send_pkg++

		//restore pdata
		queue_pool.Put(pdata)
	}

	//resize snd cache
	if len(pclient.snd_cache) == 0 && cap(pclient.snd_cache) > CLIENT_RW_CACHE_SHRINK_FACTOR*CLIENT_RW_CACHE_BASE {
		new_cap := cap(pclient.snd_cache) / 2
		if new_cap < CLIENT_RW_CACHE_BASE {
			new_cap = CLIENT_RW_CACHE_BASE
		}

		log.Debug("%s will shrink snd_cache from %d-->%d", _func_, cap(pclient.snd_cache), new_cap)
		pclient.snd_cache = make([]byte, new_cap)
	}

	log.Debug("%s send pkg:%d idx:%d", _func_, send_pkg, pclient.index)
}

/*parse read bytes to queue-data
@return: -1:error 0:complete 1:send part of data
*/
func (pclient *tcp_client) flush_send_cache(pconfig *CommConfig, pserv *TcpServ) int {
	var _func_ = "<tcp_client.flush_send_cache>"
	log := pconfig.Log
	raw_data := pclient.snd_cache
	conn := pclient.conn

	//send data
	_ = conn.SetWriteDeadline(time.Now().Add(CLIENT_RW_TIMEOUT * time.Millisecond))
	send_len, err := conn.Write(raw_data)
	//log.Debug("%s raw:%d send:%d err:%v data:%v" , _func_ , len(raw_data) , send_len , err , raw_data)

	//check err
	if err != nil { //parse err
		//net err
		if net_err, ok := err.(net.Error); ok {
			if net_err.Temporary() || net_err.Timeout() { //buff full
				log.Debug("%s buff full idx:%d", _func_, pclient.index)
				return 1
			} else { //other
				log.Err("%s connection net.err other! will close conn! detail:%v index:%d", _func_, err, pclient.index)
			}
		} else if err == io.EOF { //write a closed connection
			log.Info("%s connection closed! index:%d", _func_, pclient.index)
		} else { //other
			log.Err("%s write meets an error! will close! err:%v index:%d", _func_, err, pclient.index)
		}

		//need close
		pclient.stat = CLIENT_STAT_CLOSING
		pserv.close_ch <- pclient.index
		return -1
	}

	//check data
	if send_len < len(raw_data) {
		log.Debug("%s not all data sended! send:%d should_send:%d idx:%d", _func_, send_len, len(raw_data), pclient.index)
		raw_data = raw_data[send_len:]
		copy(pclient.snd_cache[:cap(pclient.snd_cache)], raw_data[:])
		pclient.snd_cache = pclient.snd_cache[:len(raw_data)]
		return 1
	}

	pclient.snd_cache = pclient.snd_cache[:0]
	return 0
}
